# **2장 실용주의 접근법 (A Pragmatic Approach)**

## **오늘의 TIL 요약**

- 잘 설계된 코드란 바꾸기 쉬운 코드이다. Easier to Change 기억하자!
- DRY (Don’t Repeat Yourself) 원칙을 따르자!
- 기회가 있을 때마다 코드의 구조와 직교성을 개선하여 컴포넌트 간의 상호 의존도를 줄이기 위해 노력하자.
- 되돌릴 수 없는 결정을 줄이자. 우리는 초기에 늘 최선의 결정을 내리지는 못한다.

<hr/>

## **오늘 읽은 범위**

- 2장. 실용주의 접근법(A Pragmatic Approach)

<hr/>

## **책에서 기억하고 싶은 내용 써보기**

- **좋은 설계의 핵심은 ETC(Easier to Change)**  
  좋은 설계는 나쁜 설계보다 바꾸기 쉽다. ETC(Easier to Change)는 규칙보다는 가치로, 우리가 결정을 내리게 도움을 준다. 대부분 어느 길이 변경을 쉽게 만들 수 있는 지 추측할 수 있지만 만약 실마리가 없을 경우에는 두 가지를 해보자.

  - 언제건 궁국의 '바꾸기 쉽게'라는 길을 선택하자. (모든) 작성하는 코드를 교체하기 쉽게 만들도록 노력해야 한다.
  - 자신의 직관을 발전시키는 기회로 삼자. 엔지니어링 일지에 현재 상황과 나의 선택, 그리고 변경 사항에 대한 추측을 정리해두고 소스 코드에도 이에 대한 표시를 남겨 두자. 나중에 수정하는 시점이 왔을 때 자신에게 피드백을 줄 수 있고 비슷한 갈림길을 마주쳤을 때 도움을 준다.

- **DRY: Don't Repeat Yourself**  
  소프트웨어를 신뢰성 높게 개발하는 유일한 길, 개발을 이해하고 유지 보수하기 쉽게 만드는 유일한 길은 우리가 DRY(Don't Repeat Yourself)라 부르는 원칙을 따르는 것이다. 모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다. DRY를 따르지 않으면 똑같은 것이 두 군데 이상에 표현될 것이다. 하나를 바꾸면 나머지도 바꿔야 함을 기억해야 한다. DRY 원칙은 시스템 내부의 중복을 최소화한다.

  - **DRY는 코드 밖에서도**  
    DRY는 지식의 중복, 의도의 중복에 대한 것이다. 똑같은 개념을 다른 곳 두 군데에서 표현하면 안 된다.
  - **모든 코드 중복이 지식의 중복은 아니다**  
    예를 들어, 코드는 동일하지만 두 함수가 표현하는 지식이 다른 경우라면 중복이 아니다. 두 함수는 각각 서로 다른 것을 검증하고 있지만, 우연히 규칙이 같은 것뿐이다.
  - **문서화 중복**  
    함수 이름이 함수가 하는 일을 알려준다. 더 자세한 것을 알고 싶다면 소스 코드를 보면 된다. 모든 함수에 주석을 달아야 한다는 생각은 버리자.
  - **데이터의 DRY 위반**  
    자료 구조는 지식을 표현한다. 그리고 DRY 원칙을 위배할 수 있다. 모듈이 자료 구조를 노출하면 언제나 모듈의 구현과 그 자료 구조를 사용하는 코드 사이에 결합이 생긴다. 가능하다면 언제나 객체의 속성을 읽고 쓸 때 접근자(accessor) 함수를 사용하자. 그러면 나중에 기능을 추가하기 쉬워진다.
  - **표현상의 중복**  
    개발자의 코드는 바깥세상과 연결된다. 그리고 연결될 때마다 일종의 DRY 위반을 하게 된다. 외부의 무언가에 표현된 지식을 개발자의 코드와 외부의 존재 양쪽이 알아야 하기 때문에 중복이 생긴다. 중복을 아예 피할 수는 없지만 다소 완화할 수 있다.
    - 내부 API에서 생기는 중복
    - 외부 API에서 생기는 중복
    - 데이터 저장소와의 중복
  - **개발자 간의 중복**  
    개발자 간의 중복에 대처하려면 크게는 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다. 슬랙Slack 채널같이 공통의 문제를 다루기 위한 공간을 만들어라. 코드 리뷰를 통해서 다른 사람의 소스 코드와 문서를 반드시 읽고 거기에서 배우자. 다른 사람이 여러문의 코드를 들여다보고 건드린다고 해서 기분 나빠하지 말자. 우리는 뭔가 직접 만드는 것보다 기존의 것을 찾아내고 재사용하기 쉬운 환경을 조성해야 한다. 재사용하기 쉽게 만들자.

- **직교성**  
  컴퓨터 과학에서 이 용어는 일종의 독립성이나, 결합도 줄이기(decoupling)를 의미한다. 우리가 설계하고 싶은 것은 단일하고 잘 정의된 목적을 가진 독립적인 컴포넌트이다. 컴포넌트들이 각기 격리되어 있으면 어느 하나를 바꿀 때 나머지 것들을 걱정하지 않아도 된다. 관련 없는 것들 간에 서로 영향이 없도록 하라. 직교성은 시스템 컴포넌트 간의 상호 의존도를 줄인다. 기회가 있을 때마다 코드의 구조와 직교성을 개선하기 위해 노력하자.

  - 설계  
    시스템은 서로 협력하는 모듈의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. 때로는 이런 컴포넌트들이 계층으로 묶여서 계층 단위의 추상화를 제공하기도 한다. 계층 구조는 직교적 시스템을 설계하는 강력한 방법이다.
  - 툴킷과 라이브러리  
    외부에서 만든 툴킷이나 라이브러리를 도입할 때 시스템의 직교성을 해치지 않는지 주의 깊게 살펴봐야 한다. 기술을 현명하게 선택하자.
  - 코딩
    - 코드의 결합도를 줄여라  
      부끄럼쟁이 Shy 코드를 작성하라. 즉, 불필요한 것은 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라.
    - 전역 데이터를 피하라
    - 유사한 함수를 피하라
  - 테스트  
    직교적으로 설계하고 구현한 시스템은 테스트하기 더 쉽다.
  - 문서화  
    직교성은 문서에도 적용할 수 있다. 내용과 표현이라는 두 개의 축이 있고 내용 변화 없이 모양새를 완전히 바꿀 수 있을 것이다.

- **가역성**

  > 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다. - 에밀 오귀스트 샤르티에

  되돌릴 수 없는 결정을 줄여야 하는 까닭은 우리가 프로젝트 초기에 늘 최선의 결정을 내리지는 못하기 때문이다. 결정이 바뀌지 않을 것이라 가정하고서 발생할지도 모를 우연한 사건에 대비하지 않는 데에서 실수가 나온다.  
  많은 사람들이 코드를 유연하게 유지하려고 노력한다. 아키텍처, 배포, 외부 제품과의 통합 영역을 유연하게 유지하는 데에도 관심을 기울일 필요가 있다.

- **예광탄**

  - **목표물을 찾기 위해 예광탄을 쓰자.**  
    우리는 요구 사항으로부터 최종 시스템의 일부 측면까지 빨리, 눈에 보이게, 반복적으로 도달하게 해 줄 무언가를 찾아야 한다. 시스템을 정의하는 중요한 요구 사항을 찾아라. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라. 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.  
    예광탄 코드는 한 번 쓰고 버리려고 만드는 것이 아니다. 앞으로도 계속 사용할 코드다. 예광탄 코드도 다른 제품 코드와 마찬가지로 오류 검사, 올바른 구조, 문서화, 자체 검사를 갖추어야 한다. 예광탄 코드에는 아직 모든 기능이 들어 있지 않을 뿐이다. 하지만 시스템을 구성하는 요소를 모두 연결해 놓은 후라면 목표물에 얼마나 근접했는지 확인할 수 있으며, 필요하다면 조정도 할 수 있다. 일단 정확하게 조준하고 나면 기능을 추가하는 일은 쉽다.
  - **예광탄이 언제나 목표물을 맞히는 것은 아니다.**  
    그럴 경우 목표물에 맞을 때까지 조준을 옮겨야 한다.
  - **예광탄 코드와 프로토타이핑(prototyping)**  
    프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 프로토타입은 어떤 개념을 실험해 보느라 대충 끼워 맞추어 구현한 것이므로 모두 버려야 한다. 그리고 실험 과정에서 얻은 교훈을 바탕으로 코드를 새로 작성한다. 프로토타입은 나중에 버리는 코드를 만들고 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격 중 일부가 된다. 프로토타입은 예광탄을 발사하기 전에 먼저 수행하는 정찰이나 정보 수집과 같은 것이다. 이처럼 예광탄 코드 접근 방법과 프로토타입의 접근 방법은 서로 다른 종류의 문제를 푼다.

- **프로토타입과 포스트잇**  
  프로토타입은 프로젝트의 특정 측면에 중점을 둘 수 있다. 프로토타입은 제한된 몇 가지 질문에 답하기 위한 것이므로 실제 제품보다 훨씬 적은 비용으로 빠르게 개발할 수 있다. 추후에 사용자에게 매우 중요해질지도 모르지만 일단 무시하면서 코딩할 수 있다. 하지만 세부 사항을 포기할 수 없는 환경에 처해 있다면 진짜로 프로토타입을 만들고 있는 게 맞는 지 자문해보자. 이런 경우에는 예광탄 방식의 개발이 더 적절하다.

  - **프로토타이핑 대상**  
    프로토타이핑으로 조사할 대상은 위험을 수반하는 모든 것이다. 이 전에 해 본 적이 없는 것, 최종 시스템에 매우 중요한 것이 프로토타이핑 대상이다. 증명되지 않았거나, 실험적이거나, 의심이 가는 것, 마음이 편하지 않은 것 모두가 프로토타이핑의 대상이 될 수 있다. 프로토타이핑은 학습 경험이다. 프로토타이핑의 가치는 생산한 코드에 있는 것이 아니라 이를 통해 배우는 교훈에 있다.
  - **아키텍처 프로토타이핑**  
    많은 프로토타입이 고려 중인 전체 시스템을 모델링하기 위해 만들어진다. 예광탄과는 달리 프로토타입 시스템의 모듈이 꼭 기능을 가져야 하는 것은 아니다. 프로토타이핑의 목적은 전체적으로 시스템이 어떻게 동작할지에 대해 감을 잡는 것이다. 세부 사항은 무시한다.

- **도메인 언어**

- **추정**  
  추정하는 법을 배우고 추정 능력을 계발하여 무언가의 규모를 직관적으로 짚을 정도가 되면, 추정 대상의 가능성을 가늠하는 마법과 같은 능력을 발휘할 수 있게 될 것이다. 코딩할 때에도 어떤 서브시스템을 최적화해야 하고, 어떤 서브시스템을 그대로 남겨 두어도 될지 알 수 있게 될 것이다.
  - 추정으로 놀람을 피하자.
  - 추정 실력을 기록하자.
  - 코드와 함께 일정도 반복하며 조정하자.

<hr/>

## **오늘 읽은 소감**

- 코드를 작성해서 결과를 얻는 것이 끝이 아니라 코드를 잘 작성하는 방법에 대해 생각해볼 수 있었다. 나는 코드를 작성할 때마다 함수에 주석을 달아 자세한 설명을 하곤 했는 데 그것도 DRY 원칙을 따르지 않는 좋지 않은 코드라는 것을 알았다. 함수의 이름에서 함수의 역할을 설명하고 중복을 피할 수 있도록 노력해야겠다. 코드를 작성하는 거에서 끝나는 것이 아니라 내 코드를 항상 비판적으로 바라볼 수 있는 습관을 가지자.
- 에밀 오귀스트 샤르티에가 말한 '당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다.'라는 문구가 와닿았다. 늘 처음부터 완벽하게 진행될 수는 없기 때문에 결정이 바뀌지 않을 것이라 생각하고 진행하면 안된다는 것이다. 늘 코드를 유연하게 유지하려고 노력하자. 코드를 유연하게 유지하는 것에는 DRY 원칙과 직교성도 연관되어 있다.
- 실용주의 프로그래머가 되기 위해 알려주는 내용이 쉬운 내용들은 아니라서 책을 이해하며 읽는 데 오래 걸리는 부분들도 있었다. 당장 모든 것을 적용하여 생각하고 코드를 작성하는 것은 어렵겠지만 프로그래머가 되기 위해 알아야 하는 것들을 지금 접할 수 있어서 좋았다. 나중에 프로그래머로서 일할 때 다시 이 책을 읽게 된다면 쉽게 읽히는 부분이 많아지겠지. 나중에 꼭 다시 읽어 보고 싶다.
<hr/>

## **Tips 정리하며 복습**

- TIP 14. 좋은 설계는 나쁜 설계보다 바꾸기 쉽다. (p.39)
- TIP 15. DRY: 반복하지 말라 (Don't Repeat Yourself) (p.43)
- TIP 16. 재사용하기 쉽게 만들어라. (p.54)
- TIP 17. 관련 없는 것들 간에 서로 영향이 없도록 하라. (p.56)
- TIP 18. 최종 결정이란 없다. (p.69)
- TIP 19. 유행을 좇지 말라. (p.70)
- TIP 20. 목표물을 찾기 위해 예광탄을 써라. (p.73)
- TIP 21. 프로토타입을 통해 학습하라. (p.81)
- TIP 22. 문제 도메인에 가깝게 프로그래밍하라. (p.85)
- TIP 23. 추정을 통해 놀람을 피하라. (p.95)
- TIP 24. 코드와 함께 일정도 반복하며 조정하라. (p.101)
